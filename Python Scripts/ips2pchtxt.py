import binascii
import os
import struct
import sys

HEAD_MAGIC_SIZE = 5
IPS_HEAD_MAGIC = bytearray("PATCH", 'ascii')
IPS32_HEAD_MAGIC = bytearray("IPS32", 'ascii')

IPS_ADDRESS_SIZE = 3
IPS32_ADDRESS_SIZE = 4
IPS_FOOT_MAGIC = bytearray("EOF", 'ascii')
IPS32_FOOT_MAGIC = bytearray("EEOF", 'ascii')

IPS_PATCH_LEN_STRUCT = struct.Struct('>H')

NSO_HEADER_LEN = 0x100

PATCH_TEXT_EXT = ".pchtxt"
PATCH_TEXT_ENCODING = "ascii"

PATCH_TEXT_NSOBID_ATTRIBUTE_NAME = "@nsobid-"
PATCH_TEXT_HEADER = f"\n@flag offset_shift {hex(NSO_HEADER_LEN)}\n\n// auto generated by ips2pchtxt\n@disabled\n"
PATCH_TEXT_ADDRESS_STRUCT = struct.Struct('>I')


def ips2pchtxt(ips_path, out_patch_text_path):
    ips_file = open(ips_path, 'rb')
    cur_head_magic = ips_file.read(HEAD_MAGIC_SIZE)
    if cur_head_magic == IPS_HEAD_MAGIC:
        cur_address_size = IPS_ADDRESS_SIZE
        cur_foot_magic = IPS_FOOT_MAGIC
    elif cur_head_magic == IPS32_HEAD_MAGIC:
        cur_address_size = IPS32_ADDRESS_SIZE
        cur_foot_magic = IPS32_FOOT_MAGIC
    else:
        print("Not an ips file")
        return -1

    ips_path_no_ext = os.path.splitext(ips_path)[0]
    if out_patch_text_path:
        out_patch_text_file = open(out_patch_text_path, 'wb+')
    else:
        out_patch_text_file = open(ips_path_no_ext + PATCH_TEXT_EXT, 'wb+')
    out_patch_text_file.write(PATCH_TEXT_NSOBID_ATTRIBUTE_NAME.encode(PATCH_TEXT_ENCODING))
    out_patch_text_file.write(os.path.basename(ips_path_no_ext).encode(PATCH_TEXT_ENCODING))  # assume ips name is nso bid
    out_patch_text_file.write(PATCH_TEXT_HEADER.encode(PATCH_TEXT_ENCODING))

    while True:
        cur_address_bytes = ips_file.read(cur_address_size)
        if cur_address_bytes == cur_foot_magic:
            break

        cur_address = 0
        for exponent in range(cur_address_size):
            cur_address += cur_address_bytes[cur_address_size - 1 - exponent] << (exponent * 8)
        cur_address -= NSO_HEADER_LEN

        cur_len = IPS_PATCH_LEN_STRUCT.unpack(ips_file.read(IPS_PATCH_LEN_STRUCT.size))[0]
        cur_value = ips_file.read(cur_len)

        out_patch_text_file.write(binascii.b2a_hex(PATCH_TEXT_ADDRESS_STRUCT.pack(cur_address)).upper())
        out_patch_text_file.write(" ".encode(PATCH_TEXT_ENCODING))
        out_patch_text_file.write(binascii.b2a_hex(cur_value).upper())
        out_patch_text_file.write("\n".encode(PATCH_TEXT_ENCODING))

    out_patch_text_file.close()


if __name__ == "__main__":
    ips_path = sys.argv[1]
    if len(sys.argv) > 2:
        out_patch_text_path = sys.argv[2]
    else:
        out_patch_text_path = None
    ips2pchtxt(ips_path, out_patch_text_path)
